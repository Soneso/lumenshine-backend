// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package horizon

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// HistoryTransaction is an object representing the database table.
type HistoryTransaction struct {
	TransactionHash  string            `boil:"transaction_hash" json:"transaction_hash" toml:"transaction_hash" yaml:"transaction_hash"`
	LedgerSequence   int               `boil:"ledger_sequence" json:"ledger_sequence" toml:"ledger_sequence" yaml:"ledger_sequence"`
	ApplicationOrder int               `boil:"application_order" json:"application_order" toml:"application_order" yaml:"application_order"`
	Account          string            `boil:"account" json:"account" toml:"account" yaml:"account"`
	AccountSequence  int64             `boil:"account_sequence" json:"account_sequence" toml:"account_sequence" yaml:"account_sequence"`
	FeePaid          int               `boil:"fee_paid" json:"fee_paid" toml:"fee_paid" yaml:"fee_paid"`
	OperationCount   int               `boil:"operation_count" json:"operation_count" toml:"operation_count" yaml:"operation_count"`
	CreatedAt        null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt        null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	ID               int64             `boil:"id" json:"id" toml:"id" yaml:"id"`
	TXEnvelope       string            `boil:"tx_envelope" json:"tx_envelope" toml:"tx_envelope" yaml:"tx_envelope"`
	TXResult         string            `boil:"tx_result" json:"tx_result" toml:"tx_result" yaml:"tx_result"`
	TXMeta           string            `boil:"tx_meta" json:"tx_meta" toml:"tx_meta" yaml:"tx_meta"`
	TXFeeMeta        string            `boil:"tx_fee_meta" json:"tx_fee_meta" toml:"tx_fee_meta" yaml:"tx_fee_meta"`
	Signatures       types.StringArray `boil:"signatures" json:"signatures" toml:"signatures" yaml:"signatures"`
	MemoType         string            `boil:"memo_type" json:"memo_type" toml:"memo_type" yaml:"memo_type"`
	Memo             null.String       `boil:"memo" json:"memo,omitempty" toml:"memo" yaml:"memo,omitempty"`
	TimeBounds       null.String       `boil:"time_bounds" json:"time_bounds,omitempty" toml:"time_bounds" yaml:"time_bounds,omitempty"`

	R *historyTransactionR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L historyTransactionL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var HistoryTransactionColumns = struct {
	TransactionHash  string
	LedgerSequence   string
	ApplicationOrder string
	Account          string
	AccountSequence  string
	FeePaid          string
	OperationCount   string
	CreatedAt        string
	UpdatedAt        string
	ID               string
	TXEnvelope       string
	TXResult         string
	TXMeta           string
	TXFeeMeta        string
	Signatures       string
	MemoType         string
	Memo             string
	TimeBounds       string
}{
	TransactionHash:  "transaction_hash",
	LedgerSequence:   "ledger_sequence",
	ApplicationOrder: "application_order",
	Account:          "account",
	AccountSequence:  "account_sequence",
	FeePaid:          "fee_paid",
	OperationCount:   "operation_count",
	CreatedAt:        "created_at",
	UpdatedAt:        "updated_at",
	ID:               "id",
	TXEnvelope:       "tx_envelope",
	TXResult:         "tx_result",
	TXMeta:           "tx_meta",
	TXFeeMeta:        "tx_fee_meta",
	Signatures:       "signatures",
	MemoType:         "memo_type",
	Memo:             "memo",
	TimeBounds:       "time_bounds",
}

// HistoryTransactionRels is where relationship names are stored.
var HistoryTransactionRels = struct {
}{}

// historyTransactionR is where relationships are stored.
type historyTransactionR struct {
}

// NewStruct creates a new relationship struct
func (*historyTransactionR) NewStruct() *historyTransactionR {
	return &historyTransactionR{}
}

// historyTransactionL is where Load methods for each relationship are stored.
type historyTransactionL struct{}

var (
	historyTransactionColumns               = []string{"transaction_hash", "ledger_sequence", "application_order", "account", "account_sequence", "fee_paid", "operation_count", "created_at", "updated_at", "id", "tx_envelope", "tx_result", "tx_meta", "tx_fee_meta", "signatures", "memo_type", "memo", "time_bounds"}
	historyTransactionColumnsWithoutDefault = []string{"transaction_hash", "ledger_sequence", "application_order", "account", "account_sequence", "fee_paid", "operation_count", "created_at", "updated_at", "id", "tx_envelope", "tx_result", "tx_meta", "tx_fee_meta", "memo", "time_bounds"}
	historyTransactionColumnsWithDefault    = []string{"signatures", "memo_type"}
	historyTransactionPrimaryKeyColumns     = []string{"id"}
)

type (
	// HistoryTransactionSlice is an alias for a slice of pointers to HistoryTransaction.
	// This should generally be used opposed to []HistoryTransaction.
	HistoryTransactionSlice []*HistoryTransaction
	// HistoryTransactionHook is the signature for custom HistoryTransaction hook methods
	HistoryTransactionHook func(boil.Executor, *HistoryTransaction) error

	historyTransactionQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	historyTransactionType                 = reflect.TypeOf(&HistoryTransaction{})
	historyTransactionMapping              = queries.MakeStructMapping(historyTransactionType)
	historyTransactionPrimaryKeyMapping, _ = queries.BindMapping(historyTransactionType, historyTransactionMapping, historyTransactionPrimaryKeyColumns)
	historyTransactionInsertCacheMut       sync.RWMutex
	historyTransactionInsertCache          = make(map[string]insertCache)
	historyTransactionUpdateCacheMut       sync.RWMutex
	historyTransactionUpdateCache          = make(map[string]updateCache)
	historyTransactionUpsertCacheMut       sync.RWMutex
	historyTransactionUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
)

var historyTransactionBeforeInsertHooks []HistoryTransactionHook
var historyTransactionBeforeUpdateHooks []HistoryTransactionHook
var historyTransactionBeforeDeleteHooks []HistoryTransactionHook
var historyTransactionBeforeUpsertHooks []HistoryTransactionHook

var historyTransactionAfterInsertHooks []HistoryTransactionHook
var historyTransactionAfterSelectHooks []HistoryTransactionHook
var historyTransactionAfterUpdateHooks []HistoryTransactionHook
var historyTransactionAfterDeleteHooks []HistoryTransactionHook
var historyTransactionAfterUpsertHooks []HistoryTransactionHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *HistoryTransaction) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range historyTransactionBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *HistoryTransaction) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range historyTransactionBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *HistoryTransaction) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range historyTransactionBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *HistoryTransaction) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range historyTransactionBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *HistoryTransaction) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range historyTransactionAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *HistoryTransaction) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range historyTransactionAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *HistoryTransaction) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range historyTransactionAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *HistoryTransaction) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range historyTransactionAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *HistoryTransaction) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range historyTransactionAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddHistoryTransactionHook registers your hook function for all future operations.
func AddHistoryTransactionHook(hookPoint boil.HookPoint, historyTransactionHook HistoryTransactionHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		historyTransactionBeforeInsertHooks = append(historyTransactionBeforeInsertHooks, historyTransactionHook)
	case boil.BeforeUpdateHook:
		historyTransactionBeforeUpdateHooks = append(historyTransactionBeforeUpdateHooks, historyTransactionHook)
	case boil.BeforeDeleteHook:
		historyTransactionBeforeDeleteHooks = append(historyTransactionBeforeDeleteHooks, historyTransactionHook)
	case boil.BeforeUpsertHook:
		historyTransactionBeforeUpsertHooks = append(historyTransactionBeforeUpsertHooks, historyTransactionHook)
	case boil.AfterInsertHook:
		historyTransactionAfterInsertHooks = append(historyTransactionAfterInsertHooks, historyTransactionHook)
	case boil.AfterSelectHook:
		historyTransactionAfterSelectHooks = append(historyTransactionAfterSelectHooks, historyTransactionHook)
	case boil.AfterUpdateHook:
		historyTransactionAfterUpdateHooks = append(historyTransactionAfterUpdateHooks, historyTransactionHook)
	case boil.AfterDeleteHook:
		historyTransactionAfterDeleteHooks = append(historyTransactionAfterDeleteHooks, historyTransactionHook)
	case boil.AfterUpsertHook:
		historyTransactionAfterUpsertHooks = append(historyTransactionAfterUpsertHooks, historyTransactionHook)
	}
}

// OneG returns a single historyTransaction record from the query using the global executor.
func (q historyTransactionQuery) OneG() (*HistoryTransaction, error) {
	return q.One(boil.GetDB())
}

// One returns a single historyTransaction record from the query.
func (q historyTransactionQuery) One(exec boil.Executor) (*HistoryTransaction, error) {
	o := &HistoryTransaction{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "horizon: failed to execute a one query for history_transactions")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all HistoryTransaction records from the query using the global executor.
func (q historyTransactionQuery) AllG() (HistoryTransactionSlice, error) {
	return q.All(boil.GetDB())
}

// All returns all HistoryTransaction records from the query.
func (q historyTransactionQuery) All(exec boil.Executor) (HistoryTransactionSlice, error) {
	var o []*HistoryTransaction

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "horizon: failed to assign all query results to HistoryTransaction slice")
	}

	if len(historyTransactionAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all HistoryTransaction records in the query, and panics on error.
func (q historyTransactionQuery) CountG() (int64, error) {
	return q.Count(boil.GetDB())
}

// Count returns the count of all HistoryTransaction records in the query.
func (q historyTransactionQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: failed to count history_transactions rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table, and panics on error.
func (q historyTransactionQuery) ExistsG() (bool, error) {
	return q.Exists(boil.GetDB())
}

// Exists checks if the row exists in the table.
func (q historyTransactionQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "horizon: failed to check if history_transactions exists")
	}

	return count > 0, nil
}

// HistoryTransactions retrieves all the records using an executor.
func HistoryTransactions(mods ...qm.QueryMod) historyTransactionQuery {
	mods = append(mods, qm.From("\"history_transactions\""))
	return historyTransactionQuery{NewQuery(mods...)}
}

// FindHistoryTransactionG retrieves a single record by ID.
func FindHistoryTransactionG(iD int64, selectCols ...string) (*HistoryTransaction, error) {
	return FindHistoryTransaction(boil.GetDB(), iD, selectCols...)
}

// FindHistoryTransaction retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindHistoryTransaction(exec boil.Executor, iD int64, selectCols ...string) (*HistoryTransaction, error) {
	historyTransactionObj := &HistoryTransaction{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"history_transactions\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, historyTransactionObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "horizon: unable to select from history_transactions")
	}

	return historyTransactionObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *HistoryTransaction) InsertG(columns boil.Columns) error {
	return o.Insert(boil.GetDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *HistoryTransaction) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("horizon: no history_transactions provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if queries.MustTime(o.CreatedAt).IsZero() {
		queries.SetScanner(&o.CreatedAt, currTime)
	}
	if queries.MustTime(o.UpdatedAt).IsZero() {
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(historyTransactionColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	historyTransactionInsertCacheMut.RLock()
	cache, cached := historyTransactionInsertCache[key]
	historyTransactionInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			historyTransactionColumns,
			historyTransactionColumnsWithDefault,
			historyTransactionColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(historyTransactionType, historyTransactionMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(historyTransactionType, historyTransactionMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"history_transactions\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"history_transactions\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "horizon: unable to insert into history_transactions")
	}

	if !cached {
		historyTransactionInsertCacheMut.Lock()
		historyTransactionInsertCache[key] = cache
		historyTransactionInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// UpdateG a single HistoryTransaction record using the global executor.
// See Update for more documentation.
func (o *HistoryTransaction) UpdateG(columns boil.Columns) (int64, error) {
	return o.Update(boil.GetDB(), columns)
}

// Update uses an executor to update the HistoryTransaction.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *HistoryTransaction) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	queries.SetScanner(&o.UpdatedAt, currTime)

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	historyTransactionUpdateCacheMut.RLock()
	cache, cached := historyTransactionUpdateCache[key]
	historyTransactionUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			historyTransactionColumns,
			historyTransactionPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("horizon: unable to update history_transactions, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"history_transactions\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, historyTransactionPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(historyTransactionType, historyTransactionMapping, append(wl, historyTransactionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to update history_transactions row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "horizon: failed to get rows affected by update for history_transactions")
	}

	if !cached {
		historyTransactionUpdateCacheMut.Lock()
		historyTransactionUpdateCache[key] = cache
		historyTransactionUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q historyTransactionQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to update all for history_transactions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to retrieve rows affected for history_transactions")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o HistoryTransactionSlice) UpdateAllG(cols M) (int64, error) {
	return o.UpdateAll(boil.GetDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o HistoryTransactionSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("horizon: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), historyTransactionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"history_transactions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, historyTransactionPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to update all in historyTransaction slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to retrieve rows affected all in update all historyTransaction")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *HistoryTransaction) UpsertG(updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(boil.GetDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *HistoryTransaction) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("horizon: no history_transactions provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if queries.MustTime(o.CreatedAt).IsZero() {
		queries.SetScanner(&o.CreatedAt, currTime)
	}
	queries.SetScanner(&o.UpdatedAt, currTime)

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(historyTransactionColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	historyTransactionUpsertCacheMut.RLock()
	cache, cached := historyTransactionUpsertCache[key]
	historyTransactionUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			historyTransactionColumns,
			historyTransactionColumnsWithDefault,
			historyTransactionColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			historyTransactionColumns,
			historyTransactionPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("horizon: unable to upsert history_transactions, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(historyTransactionPrimaryKeyColumns))
			copy(conflict, historyTransactionPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"history_transactions\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(historyTransactionType, historyTransactionMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(historyTransactionType, historyTransactionMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "horizon: unable to upsert history_transactions")
	}

	if !cached {
		historyTransactionUpsertCacheMut.Lock()
		historyTransactionUpsertCache[key] = cache
		historyTransactionUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// DeleteG deletes a single HistoryTransaction record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *HistoryTransaction) DeleteG() (int64, error) {
	return o.Delete(boil.GetDB())
}

// Delete deletes a single HistoryTransaction record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *HistoryTransaction) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("horizon: no HistoryTransaction provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), historyTransactionPrimaryKeyMapping)
	sql := "DELETE FROM \"history_transactions\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to delete from history_transactions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "horizon: failed to get rows affected by delete for history_transactions")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q historyTransactionQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("horizon: no historyTransactionQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to delete all from history_transactions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "horizon: failed to get rows affected by deleteall for history_transactions")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o HistoryTransactionSlice) DeleteAllG() (int64, error) {
	return o.DeleteAll(boil.GetDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o HistoryTransactionSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("horizon: no HistoryTransaction slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(historyTransactionBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), historyTransactionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"history_transactions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, historyTransactionPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to delete all from historyTransaction slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "horizon: failed to get rows affected by deleteall for history_transactions")
	}

	if len(historyTransactionAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *HistoryTransaction) ReloadG() error {
	if o == nil {
		return errors.New("horizon: no HistoryTransaction provided for reload")
	}

	return o.Reload(boil.GetDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *HistoryTransaction) Reload(exec boil.Executor) error {
	ret, err := FindHistoryTransaction(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *HistoryTransactionSlice) ReloadAllG() error {
	if o == nil {
		return errors.New("horizon: empty HistoryTransactionSlice provided for reload all")
	}

	return o.ReloadAll(boil.GetDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *HistoryTransactionSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := HistoryTransactionSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), historyTransactionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"history_transactions\".* FROM \"history_transactions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, historyTransactionPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "horizon: unable to reload all in HistoryTransactionSlice")
	}

	*o = slice

	return nil
}

// HistoryTransactionExistsG checks if the HistoryTransaction row exists.
func HistoryTransactionExistsG(iD int64) (bool, error) {
	return HistoryTransactionExists(boil.GetDB(), iD)
}

// HistoryTransactionExists checks if the HistoryTransaction row exists.
func HistoryTransactionExists(exec boil.Executor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"history_transactions\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "horizon: unable to check if history_transactions exists")
	}

	return exists, nil
}
