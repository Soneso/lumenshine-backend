// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package horizon

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// HistoryLedger is an object representing the database table.
type HistoryLedger struct {
	Sequence           int         `boil:"sequence" json:"sequence" toml:"sequence" yaml:"sequence"`
	LedgerHash         string      `boil:"ledger_hash" json:"ledger_hash" toml:"ledger_hash" yaml:"ledger_hash"`
	PreviousLedgerHash null.String `boil:"previous_ledger_hash" json:"previous_ledger_hash,omitempty" toml:"previous_ledger_hash" yaml:"previous_ledger_hash,omitempty"`
	TransactionCount   int         `boil:"transaction_count" json:"transaction_count" toml:"transaction_count" yaml:"transaction_count"`
	OperationCount     int         `boil:"operation_count" json:"operation_count" toml:"operation_count" yaml:"operation_count"`
	ClosedAt           time.Time   `boil:"closed_at" json:"closed_at" toml:"closed_at" yaml:"closed_at"`
	CreatedAt          null.Time   `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt          null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	ID                 int64       `boil:"id" json:"id" toml:"id" yaml:"id"`
	ImporterVersion    int         `boil:"importer_version" json:"importer_version" toml:"importer_version" yaml:"importer_version"`
	TotalCoins         int64       `boil:"total_coins" json:"total_coins" toml:"total_coins" yaml:"total_coins"`
	FeePool            int64       `boil:"fee_pool" json:"fee_pool" toml:"fee_pool" yaml:"fee_pool"`
	BaseFee            int         `boil:"base_fee" json:"base_fee" toml:"base_fee" yaml:"base_fee"`
	BaseReserve        int         `boil:"base_reserve" json:"base_reserve" toml:"base_reserve" yaml:"base_reserve"`
	MaxTXSetSize       int         `boil:"max_tx_set_size" json:"max_tx_set_size" toml:"max_tx_set_size" yaml:"max_tx_set_size"`
	ProtocolVersion    int         `boil:"protocol_version" json:"protocol_version" toml:"protocol_version" yaml:"protocol_version"`
	LedgerHeader       null.String `boil:"ledger_header" json:"ledger_header,omitempty" toml:"ledger_header" yaml:"ledger_header,omitempty"`

	R *historyLedgerR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L historyLedgerL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var HistoryLedgerColumns = struct {
	Sequence           string
	LedgerHash         string
	PreviousLedgerHash string
	TransactionCount   string
	OperationCount     string
	ClosedAt           string
	CreatedAt          string
	UpdatedAt          string
	ID                 string
	ImporterVersion    string
	TotalCoins         string
	FeePool            string
	BaseFee            string
	BaseReserve        string
	MaxTXSetSize       string
	ProtocolVersion    string
	LedgerHeader       string
}{
	Sequence:           "sequence",
	LedgerHash:         "ledger_hash",
	PreviousLedgerHash: "previous_ledger_hash",
	TransactionCount:   "transaction_count",
	OperationCount:     "operation_count",
	ClosedAt:           "closed_at",
	CreatedAt:          "created_at",
	UpdatedAt:          "updated_at",
	ID:                 "id",
	ImporterVersion:    "importer_version",
	TotalCoins:         "total_coins",
	FeePool:            "fee_pool",
	BaseFee:            "base_fee",
	BaseReserve:        "base_reserve",
	MaxTXSetSize:       "max_tx_set_size",
	ProtocolVersion:    "protocol_version",
	LedgerHeader:       "ledger_header",
}

// HistoryLedgerRels is where relationship names are stored.
var HistoryLedgerRels = struct {
}{}

// historyLedgerR is where relationships are stored.
type historyLedgerR struct {
}

// NewStruct creates a new relationship struct
func (*historyLedgerR) NewStruct() *historyLedgerR {
	return &historyLedgerR{}
}

// historyLedgerL is where Load methods for each relationship are stored.
type historyLedgerL struct{}

var (
	historyLedgerColumns               = []string{"sequence", "ledger_hash", "previous_ledger_hash", "transaction_count", "operation_count", "closed_at", "created_at", "updated_at", "id", "importer_version", "total_coins", "fee_pool", "base_fee", "base_reserve", "max_tx_set_size", "protocol_version", "ledger_header"}
	historyLedgerColumnsWithoutDefault = []string{"sequence", "ledger_hash", "previous_ledger_hash", "closed_at", "created_at", "updated_at", "id", "total_coins", "fee_pool", "base_fee", "base_reserve", "max_tx_set_size", "ledger_header"}
	historyLedgerColumnsWithDefault    = []string{"transaction_count", "operation_count", "importer_version", "protocol_version"}
	historyLedgerPrimaryKeyColumns     = []string{"id"}
)

type (
	// HistoryLedgerSlice is an alias for a slice of pointers to HistoryLedger.
	// This should generally be used opposed to []HistoryLedger.
	HistoryLedgerSlice []*HistoryLedger
	// HistoryLedgerHook is the signature for custom HistoryLedger hook methods
	HistoryLedgerHook func(boil.Executor, *HistoryLedger) error

	historyLedgerQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	historyLedgerType                 = reflect.TypeOf(&HistoryLedger{})
	historyLedgerMapping              = queries.MakeStructMapping(historyLedgerType)
	historyLedgerPrimaryKeyMapping, _ = queries.BindMapping(historyLedgerType, historyLedgerMapping, historyLedgerPrimaryKeyColumns)
	historyLedgerInsertCacheMut       sync.RWMutex
	historyLedgerInsertCache          = make(map[string]insertCache)
	historyLedgerUpdateCacheMut       sync.RWMutex
	historyLedgerUpdateCache          = make(map[string]updateCache)
	historyLedgerUpsertCacheMut       sync.RWMutex
	historyLedgerUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
)

var historyLedgerBeforeInsertHooks []HistoryLedgerHook
var historyLedgerBeforeUpdateHooks []HistoryLedgerHook
var historyLedgerBeforeDeleteHooks []HistoryLedgerHook
var historyLedgerBeforeUpsertHooks []HistoryLedgerHook

var historyLedgerAfterInsertHooks []HistoryLedgerHook
var historyLedgerAfterSelectHooks []HistoryLedgerHook
var historyLedgerAfterUpdateHooks []HistoryLedgerHook
var historyLedgerAfterDeleteHooks []HistoryLedgerHook
var historyLedgerAfterUpsertHooks []HistoryLedgerHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *HistoryLedger) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range historyLedgerBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *HistoryLedger) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range historyLedgerBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *HistoryLedger) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range historyLedgerBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *HistoryLedger) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range historyLedgerBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *HistoryLedger) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range historyLedgerAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *HistoryLedger) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range historyLedgerAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *HistoryLedger) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range historyLedgerAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *HistoryLedger) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range historyLedgerAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *HistoryLedger) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range historyLedgerAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddHistoryLedgerHook registers your hook function for all future operations.
func AddHistoryLedgerHook(hookPoint boil.HookPoint, historyLedgerHook HistoryLedgerHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		historyLedgerBeforeInsertHooks = append(historyLedgerBeforeInsertHooks, historyLedgerHook)
	case boil.BeforeUpdateHook:
		historyLedgerBeforeUpdateHooks = append(historyLedgerBeforeUpdateHooks, historyLedgerHook)
	case boil.BeforeDeleteHook:
		historyLedgerBeforeDeleteHooks = append(historyLedgerBeforeDeleteHooks, historyLedgerHook)
	case boil.BeforeUpsertHook:
		historyLedgerBeforeUpsertHooks = append(historyLedgerBeforeUpsertHooks, historyLedgerHook)
	case boil.AfterInsertHook:
		historyLedgerAfterInsertHooks = append(historyLedgerAfterInsertHooks, historyLedgerHook)
	case boil.AfterSelectHook:
		historyLedgerAfterSelectHooks = append(historyLedgerAfterSelectHooks, historyLedgerHook)
	case boil.AfterUpdateHook:
		historyLedgerAfterUpdateHooks = append(historyLedgerAfterUpdateHooks, historyLedgerHook)
	case boil.AfterDeleteHook:
		historyLedgerAfterDeleteHooks = append(historyLedgerAfterDeleteHooks, historyLedgerHook)
	case boil.AfterUpsertHook:
		historyLedgerAfterUpsertHooks = append(historyLedgerAfterUpsertHooks, historyLedgerHook)
	}
}

// OneG returns a single historyLedger record from the query using the global executor.
func (q historyLedgerQuery) OneG() (*HistoryLedger, error) {
	return q.One(boil.GetDB())
}

// One returns a single historyLedger record from the query.
func (q historyLedgerQuery) One(exec boil.Executor) (*HistoryLedger, error) {
	o := &HistoryLedger{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "horizon: failed to execute a one query for history_ledgers")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all HistoryLedger records from the query using the global executor.
func (q historyLedgerQuery) AllG() (HistoryLedgerSlice, error) {
	return q.All(boil.GetDB())
}

// All returns all HistoryLedger records from the query.
func (q historyLedgerQuery) All(exec boil.Executor) (HistoryLedgerSlice, error) {
	var o []*HistoryLedger

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "horizon: failed to assign all query results to HistoryLedger slice")
	}

	if len(historyLedgerAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all HistoryLedger records in the query, and panics on error.
func (q historyLedgerQuery) CountG() (int64, error) {
	return q.Count(boil.GetDB())
}

// Count returns the count of all HistoryLedger records in the query.
func (q historyLedgerQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: failed to count history_ledgers rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table, and panics on error.
func (q historyLedgerQuery) ExistsG() (bool, error) {
	return q.Exists(boil.GetDB())
}

// Exists checks if the row exists in the table.
func (q historyLedgerQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "horizon: failed to check if history_ledgers exists")
	}

	return count > 0, nil
}

// HistoryLedgers retrieves all the records using an executor.
func HistoryLedgers(mods ...qm.QueryMod) historyLedgerQuery {
	mods = append(mods, qm.From("\"history_ledgers\""))
	return historyLedgerQuery{NewQuery(mods...)}
}

// FindHistoryLedgerG retrieves a single record by ID.
func FindHistoryLedgerG(iD int64, selectCols ...string) (*HistoryLedger, error) {
	return FindHistoryLedger(boil.GetDB(), iD, selectCols...)
}

// FindHistoryLedger retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindHistoryLedger(exec boil.Executor, iD int64, selectCols ...string) (*HistoryLedger, error) {
	historyLedgerObj := &HistoryLedger{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"history_ledgers\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, historyLedgerObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "horizon: unable to select from history_ledgers")
	}

	return historyLedgerObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *HistoryLedger) InsertG(columns boil.Columns) error {
	return o.Insert(boil.GetDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *HistoryLedger) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("horizon: no history_ledgers provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if queries.MustTime(o.CreatedAt).IsZero() {
		queries.SetScanner(&o.CreatedAt, currTime)
	}
	if queries.MustTime(o.UpdatedAt).IsZero() {
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(historyLedgerColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	historyLedgerInsertCacheMut.RLock()
	cache, cached := historyLedgerInsertCache[key]
	historyLedgerInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			historyLedgerColumns,
			historyLedgerColumnsWithDefault,
			historyLedgerColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(historyLedgerType, historyLedgerMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(historyLedgerType, historyLedgerMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"history_ledgers\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"history_ledgers\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "horizon: unable to insert into history_ledgers")
	}

	if !cached {
		historyLedgerInsertCacheMut.Lock()
		historyLedgerInsertCache[key] = cache
		historyLedgerInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// UpdateG a single HistoryLedger record using the global executor.
// See Update for more documentation.
func (o *HistoryLedger) UpdateG(columns boil.Columns) (int64, error) {
	return o.Update(boil.GetDB(), columns)
}

// Update uses an executor to update the HistoryLedger.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *HistoryLedger) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	queries.SetScanner(&o.UpdatedAt, currTime)

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	historyLedgerUpdateCacheMut.RLock()
	cache, cached := historyLedgerUpdateCache[key]
	historyLedgerUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			historyLedgerColumns,
			historyLedgerPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("horizon: unable to update history_ledgers, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"history_ledgers\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, historyLedgerPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(historyLedgerType, historyLedgerMapping, append(wl, historyLedgerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to update history_ledgers row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "horizon: failed to get rows affected by update for history_ledgers")
	}

	if !cached {
		historyLedgerUpdateCacheMut.Lock()
		historyLedgerUpdateCache[key] = cache
		historyLedgerUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q historyLedgerQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to update all for history_ledgers")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to retrieve rows affected for history_ledgers")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o HistoryLedgerSlice) UpdateAllG(cols M) (int64, error) {
	return o.UpdateAll(boil.GetDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o HistoryLedgerSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("horizon: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), historyLedgerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"history_ledgers\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, historyLedgerPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to update all in historyLedger slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to retrieve rows affected all in update all historyLedger")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *HistoryLedger) UpsertG(updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(boil.GetDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *HistoryLedger) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("horizon: no history_ledgers provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if queries.MustTime(o.CreatedAt).IsZero() {
		queries.SetScanner(&o.CreatedAt, currTime)
	}
	queries.SetScanner(&o.UpdatedAt, currTime)

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(historyLedgerColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	historyLedgerUpsertCacheMut.RLock()
	cache, cached := historyLedgerUpsertCache[key]
	historyLedgerUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			historyLedgerColumns,
			historyLedgerColumnsWithDefault,
			historyLedgerColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			historyLedgerColumns,
			historyLedgerPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("horizon: unable to upsert history_ledgers, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(historyLedgerPrimaryKeyColumns))
			copy(conflict, historyLedgerPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"history_ledgers\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(historyLedgerType, historyLedgerMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(historyLedgerType, historyLedgerMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "horizon: unable to upsert history_ledgers")
	}

	if !cached {
		historyLedgerUpsertCacheMut.Lock()
		historyLedgerUpsertCache[key] = cache
		historyLedgerUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// DeleteG deletes a single HistoryLedger record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *HistoryLedger) DeleteG() (int64, error) {
	return o.Delete(boil.GetDB())
}

// Delete deletes a single HistoryLedger record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *HistoryLedger) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("horizon: no HistoryLedger provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), historyLedgerPrimaryKeyMapping)
	sql := "DELETE FROM \"history_ledgers\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to delete from history_ledgers")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "horizon: failed to get rows affected by delete for history_ledgers")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q historyLedgerQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("horizon: no historyLedgerQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to delete all from history_ledgers")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "horizon: failed to get rows affected by deleteall for history_ledgers")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o HistoryLedgerSlice) DeleteAllG() (int64, error) {
	return o.DeleteAll(boil.GetDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o HistoryLedgerSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("horizon: no HistoryLedger slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(historyLedgerBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), historyLedgerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"history_ledgers\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, historyLedgerPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "horizon: unable to delete all from historyLedger slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "horizon: failed to get rows affected by deleteall for history_ledgers")
	}

	if len(historyLedgerAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *HistoryLedger) ReloadG() error {
	if o == nil {
		return errors.New("horizon: no HistoryLedger provided for reload")
	}

	return o.Reload(boil.GetDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *HistoryLedger) Reload(exec boil.Executor) error {
	ret, err := FindHistoryLedger(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *HistoryLedgerSlice) ReloadAllG() error {
	if o == nil {
		return errors.New("horizon: empty HistoryLedgerSlice provided for reload all")
	}

	return o.ReloadAll(boil.GetDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *HistoryLedgerSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := HistoryLedgerSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), historyLedgerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"history_ledgers\".* FROM \"history_ledgers\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, historyLedgerPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "horizon: unable to reload all in HistoryLedgerSlice")
	}

	*o = slice

	return nil
}

// HistoryLedgerExistsG checks if the HistoryLedger row exists.
func HistoryLedgerExistsG(iD int64) (bool, error) {
	return HistoryLedgerExists(boil.GetDB(), iD)
}

// HistoryLedgerExists checks if the HistoryLedger row exists.
func HistoryLedgerExists(exec boil.Executor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"history_ledgers\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "horizon: unable to check if history_ledgers exists")
	}

	return exists, nil
}
